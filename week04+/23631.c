// https://www.acmicpc.net/problem/23631
// 진심 좌우 반복뛰기

// 문제
// 히어로 협회에는 아래와 같은 두 가지 소문이 있다.
// 진심 좌우 반복 뛰기를 10^100일 동안 반복하면 히어로가 된다. 뛴 거리의 총합이 N m 이상이면 대머리가 된다.
// 지나가던 제로x는 소문을 듣고 진심 좌우 반복 뛰기를 하기로 결심했다. 진심 좌우 반복 뛰기는 간단하다.
// 위치 x = 0에서 시작하여, 처음에는 오른쪽으로 K m를 뛴 다음 방향을 바꾼다.
// 방향을 바꿀 때마다 이전에 움직인 거리에 K m만큼 더한 거리를 뛰고, 다시 방향을 바꾼다.
// 예를 들어, K = 2 라면, 오른쪽으로 2 m, 왼쪽으로 4 m, 오른쪽으로 6 m, ...
// 하지만, 제로x는 대머리가 되는 것이 너무나도 싫었다. 즉, 소문에 따라 뛴 거리의 총합이 N m 이상이 되지 않아야 한다.
// 대머리가 되지 않으면서도 운동의 효과는 보고 싶었던 제로x는 정확히 (N - 1)m만 뛸 것이다.
// 하지만 제로x는 어디서 멈춰야 하는지 계산할 수 없었다. 제로x가 대머리가 되지 않도록 도와주자!
// (N - 1) m를 뜀과 동시에 전환점에 도달할 경우, 방향을 바꾸고 멈춘다. 예제 1의 두 번째 테스트 케이스를 참고하자.

// 입력
// 첫 번째 줄에 테스트 케이스 수 T가 주어진다. 두 번째 줄부터 T개의 줄에는 자연수 N, K가 공백으로 구분되어 주어진다.
// 1 ≤ T ≤ 100, 1 ≤ N,K ≤ 10,000,000

// 출력
// 제로x가 멈춰야 하는 
// $x$좌표와 바라보고 있게 될 방향을 출력한다. 방향을 출력할 때 오른쪽은 R, 왼쪽은 L로 나타낸다.

// 예제 입력 1 
// 3
// 15 3
// 7 2
// 20 7
// 예제 출력 1 
// 2 R
// -2 R
// -5 L
// 예제 입력 2 
// 4
// 1 1
// 1 10000000
// 10000000 1
// 10000000 10000000
// 예제 출력 2 
// 0 R
// 0 R
// -607 L
// 9999999 R

#include <stdio.h>
#include <math.h>
int main() {
//////////////////////////////////////
int testcase; scanf("%d", &testcase);
for (int t = 0; t < testcase; t++) {
    int n, k; scanf("%d %d", &n, &k);
    double ans = -0.5 + sqrt(0.5+2*(n-1)/k);
    int round = (int) ans;
    int diff = n - k*round*(round+1)/2 - 1;
    int dir = 1-2*(round%2);
    int startpoint = (-dir)*k*((round+1)/2);
    printf("%d %c\n", startpoint+dir*diff, dir==1?'R':'L');
}
//////////////////////////////////////
return 0;}